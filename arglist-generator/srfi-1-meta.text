(cons a d -> pair)
(list object ... -> list)
(xcons d a -> pair)
(cons* elt1 elt2 ... -> object)
(make-list n [fill] -> list)
(list-tabulate n init-proc -> list)
(list-copy flist -> flist)
(circular-list elt1 elt2 ... -> list)
(iota count [start step] -> list)
(proper-list? x -> boolean)
(circular-list? x -> boolean)
(dotted-list? x -> boolean)
(pair? object -> boolean)
(null? object -> boolean)
(null-list? list -> boolean)
(not-pair? x -> boolean)
(list= elt= list1 ... -> boolean)
(car pair -> value)
(cdr pair -> value)
(caar pair -> value)
(cadr pair -> value)
(cdddar pair -> value)
(cddddr pair -> value)
(list-ref clist i -> value)
(first pair -> object)
(second pair -> object)
(third pair -> object)
(fourth pair -> object)
(fifth pair -> object)
(sixth pair -> object)
(seventh pair -> object)
(eighth pair -> object)
(ninth pair -> object)
(tenth pair -> object)
(car+cdr pair -> [x y])
(take x i -> list)
(drop x i -> object)
(take-right flist i -> object)
(drop-right flist i -> list)
(take! x i -> list)
(drop-right! flist i -> list)
(split-at x i -> [list object])
(split-at! x i -> [list object])
(last pair -> object)
(last-pair pair -> pair)
(length list -> integer)
(length+ clist -> integer or #f)
(append list1 ... -> list)
(append! list1 ... -> list)
(concatenate list-of-lists -> value)
(concatenate! list-of-lists -> value)
(reverse list -> list)
(reverse! list -> list)
(append-reverse rev-head tail -> list)
(append-reverse! rev-head tail -> list)
(zip clist1 clist2 ... -> list)
(unzip1 list -> list)
(unzip2 list -> [list list])
(unzip3 list -> [list list list])
(unzip4 list -> [list list list list])
(unzip5 list -> [list list list list list])
(count pred clist1 clist2 -> integer)
(fold kons knil clist1 clist2 ... -> value)
(fold-right kons knil clist1 clist2 ... -> value)
(pair-fold kons knil clist1 clist2 ... -> value)
(pair-fold-right kons knil clist1 clist2 ... -> value)
(reduce f ridentity list -> value)
(reduce-right f ridentity list -> value)
(unfold p f g seed [tail-gen] -> list)
(unfold-right p f g seed [tail] -> list)
(map proc clist1 clist2 ... -> list)
(for-each proc clist1 clist2 ... -> unspecified)
(append-map f clist1 clist2 ... -> value)
(append-map! f clist1 clist2 ... -> value)
(map! f list1 clist2 ... -> list)
(map-in-order f clist1 clist2 ... -> list)
(pair-for-each f clist1 clist2 ... -> unspecific)
(filter-map f clist1 clist2 ... -> list)
(filter pred list -> list)
(partition pred list -> [list list])
(remove pred list -> list)
(filter! pred list -> list)
(partition! pred list -> [list list])
(remove! pred list -> list)
(find pred clist -> value)
(find-tail pred clist -> pair or false)
(take-while pred clist -> list)
(take-while! pred clist -> list)
(drop-while pred clist -> list)
(span pred clist -> [list clist])
(span! pred list -> [list list])
(break pred clist -> [list clist])
(break! pred list -> [list list])
(any pred clist1 clist2 ... -> value)
(every pred clist1 clist2 ... -> value)
(list-index pred clist1 clist2 ... -> integer or false)
(member x list [=] -> list)
(memq x list -> list)
(memv x list -> list)
(delete x list [=] -> list)
(delete! x list [=] -> list)
(delete-duplicates list [=] -> list)
(delete-duplicates! list [=] -> list)
(assoc key alist [=] -> pair or #f)
(assq key alist -> pair or #f)
(assv key alist -> pair or #f)
(alist-cons key datum alist -> alist)
(alist-copy alist -> alist)
(alist-delete key alist [=] -> alist)
(alist-delete! key alist [=] -> alist)
(lset<= = list1 ... -> boolean)
(lset= = list1 list2 ... -> boolean)
(lset-adjoin = list elt1 ... -> list)
(lset-union = list1 ... -> list)
(lset-intersection = list1 list2 ... -> list)
(lset-difference = list1 list2 ... -> list)
(lset-xor = list1 ... -> list)
(lset-diff+intersection = list1 list2 ... -> [list list])
(lset-union! = list1 ... -> list)
(lset-intersection! = list1 list2 ... -> list)
(lset-difference! = list1 list2 ... -> list)
(lset-xor! = list1 ... -> list)
(lset-diff+intersection! = list1 list2 ... -> [list list])
(set-car! pair object -> unspecified)
(set-cdr! pair object -> unspecified)
